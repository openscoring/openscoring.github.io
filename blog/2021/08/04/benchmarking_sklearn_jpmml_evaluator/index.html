<!DOCTYPE html>
<html lang="en">

<head>
  <script src="https://www.googletagmanager.com/gtag/js?id=G-1XC1KCZX17" async></script>

<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}

  gtag('js', new Date());
  gtag('config', 'G-1XC1KCZX17');
</script>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
  <meta name="format-detection" content="telephone=no">
  <meta name="theme-color" content="#ffffff">
  <meta name="msapplication-navbutton-color" content="#ffffff">
  <meta name="apple-mobile-web-app-status-bar-style" content="#ffffff">

  <meta name="description" content="">
  <meta name="keywords" content="scikit-learn jpmml-evaluator jpmml-evaluator-python optimization">
  <meta name="author" content="vruusmann">

  <title>Benchmarking Scikit-Learn against JPMML-Evaluator - Openscoring</title>

  <meta name="robots" content="index, follow, max-snippet:-1, max-video-preview:-1, max-image-preview:large">
  <link rel="canonical" href="https://openscoring.io/blog/2021/08/04/benchmarking_sklearn_jpmml_evaluator/">
  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Benchmarking Scikit-Learn against JPMML-Evaluator - Openscoring">
  <meta property="og:url" content="/blog/2021/08/04/benchmarking_sklearn_jpmml_evaluator/">
  <meta property="og:site_name" content="Openscoring">
  <meta property="og:updated_time" content="2021-08-04 00:00:00 +0300">
  <meta property="article:published_time" content="2021-08-04 00:00:00 +0300">
  <meta property="article:modified_time" content="2021-08-04 00:00:00 +0300">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Benchmarking Scikit-Learn against JPMML-Evaluator - Openscoring">
  <meta name="twitter:label1" content="Written by">
  <meta name="twitter:data1" content="Villu Ruusmann">
  <meta name="twitter:label2" content="Time to read">
  <meta name="twitter:data2" content="Less than a minute">

  <link rel="icon" href="/assets/images/fa-150x150.png" sizes="32x32">
  <link rel="icon" href="/assets/images/fa.png" sizes="192x192">
  <link rel="apple-touch-icon" href="/assets/images/fa.png">
  <link rel="stylesheet" href="/assets/css/main.css">
  <meta name="msapplication-TileImage" content="h/assets/images/fa.png">
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<body>
  <header class="header">
  <div class="container">
    <nav class="nav--main">
      <a class="logo" href="/" aria-label="home">
        <img src="/assets/images/logo.svg" alt="" width="35" height="32" loading="lazy">
        <span>Openscoring</span>
      </a>

      <input type="checkbox" id="nav__toggle--main" class="nav__toggle">
      <label for="nav__toggle--main">Menu<span></span></label>

      <div class="menu">
        <ul id="menu--main">
          <li><a href="/#overview" aria-current="page">Overview</a></li>
          <li><a href="/#products" aria-current="page">Products</a></li>
          <li><a href="/#licensing" aria-current="page">Licensing</a></li>
          <li><a href="/#consulting" aria-current="page">Consulting</a></li>
        </ul>
      </div>

      <label for="nav__toggle--main" class="overlay"></label>

      <a href="/blog/" class="btn btn--small">Blog</a>
    </nav>
  </div>
</header>

  <main class="container mt-26">
    <h1>Benchmarking Scikit-Learn against JPMML-Evaluator</h1>
  
<div class="post">
  <h3 id="overview">Overview</h3>

<p>A ML framework design is a trade-off between training and deployment efficiency. Finding a balance is hard, because these two application areas are conceptually and technically rather different.</p>

<p>During model training, the data is available in its entirety. The technical challenge is loading this dataset into memory, and running numerical optimization algorithms on it.
Model training does not lend itself easily to non-batch processing approaches, because the effective formulation and testing of statistical hypotheses is not possible without sufficient evidence. However, once available, a model can be updated using mini-batch or stream processing approaches (aka “online learning”).</p>

<p>During model deployment, the data is presented over time in variable size chunks. One end of the spectrum is real-time prediction, where the chunk size is one. The other end is batch prediction, where the chunk size could be in millions.
However, there is a practical upper limit to chunk size, as dictated by available computer resources.</p>

<p>Model deployment has room for specialization.</p>

<p>ML frameworks that prioritize deployment are likely to offer additional APIs.
The case in point is real-time prediction, where the technical challenge is evaluating an isolated data record as fast as possible.
Replacing a batch-oriented API with a dedicated data record-oriented API allows the application to avoid unnecessary and expensive interconversions between data records and 1-row data matrices.</p>

<h5 id="scikit-learn">Scikit-Learn</h5>

<p>Scikit-Learn is designed for running classical ML algorithms on relatively small datasets.
The high-level business logic is implemented in Python. All the heavy-lifting is dispatched to the C language layer (Cython and/or C-based libraries such as NumPy, SciPy).</p>

<p>The design is influenced by the desire to maximize the usage of vectorized math operations.
Vectorization shines during model training when the data is presented as a single large data matrix.
However, it loses its luster (to varying degrees) during model deployment, when the data is presented as multiple variable-size data matrices.
Vectorization gains disappear when dealing with 1-row data matrices.</p>

<p>The scaling properties of transformer and model types can be deduced from their “vectorizability”.</p>

<p>Vectorized math is only possible with (floating point-) numeric features.
If the dataset contains complex data type features (eg. categoricals, temporals, user-defined data types), then the transformation to numeric representation is likely to involve computations that are not vectorizable.
For example, the binarization of categorical string features using one-hot encoding involves compiling a vocabulary and performing string value lookups against it.</p>

<p>The prediction algorithm of many popular model types is either fully (eg. linear models, neural networks, support vector machines) or to a great degree (eg. ensemble models) expressible in terms of matrix (linar algebra) operations.
There are only a few model types that can do without. The best example are decision trees, which rely on conditional logic instead.</p>

<p>Scikit-Learn holds data using Numpy arrays that support different representations.
The default data representation is dense, which has low computational overhead, but requires large contiguous blocks of memory.
As the size of the dataset increases, this requirements becomes harder to satisfy.</p>

<p>The data and the execution algorithm can be kept “in-core” longer by changing the data representation from dense to sparse.
For maximum effect, must choose a specific sparse matrix implementation depending on the compression axis (rows vs. columns), and the compression rate (high-density vs. low-density).</p>

<p>Switching the data representation from dense to sparse typically introduces very significant computational overhead, because cell values must be retrieved individually.
The extra work is carried out automatically deep inside the C language layer. The application developer perceives a performance degradation, but cannot do much about it.</p>

<p>Some Scikit-Learn algorithms contain different execution paths for dense vs. sparse data. Some may even refuse to deal with the latter.</p>

<p>Another expensive operation that is often overlooked is the concatenation of child transformer results by the parent (meta-)transformer.
If the workflow is struggling due to memory constraints, then this may be the place where the eventual out-of-memory error is raised. The need for extra memory management work can be reduced by reordering and grouping columns, optimizing and streamlining the type of data matrices, etc.</p>

<h5 id="jpmml-evaluator">JPMML-Evaluator</h5>

<p>The <a href="https://github.com/jpmml/jpmml-evaluator">JPMML-Evaluator</a> library is designed for making predictions on isolated data records. There is no functional need for vectorized math operations, C language libraries, or GPU/TPU acceleration.</p>

<p>The main selling point is quick and constant scoring times.
The cost of evaluating a batch of N data records equals N times the cost of evaluating the “average” data record.</p>

<p>All application scenarios are handled by the same data record-oriented API.
The elimination of batching, both conceptually and practically, guarantees strictly linear scaling properties, and gives JPMML-Evaluator the potential to outperform Scikit-Learn.</p>

<p>The PMML representation of data and pipelines uses high-level concepts.
It does not need to bother itself with data conversions from the rich real-life value space to a simplified numeric value space, nor data sparsity.</p>

<p>Last but not least, performing any kind of benchmarking on the Java/JVM platform assumes that the JVM has been properly “warmed up”.
A JVM starts “cold”. It gets warmer by monitoring the running application, and automatically identifying and optimizing performance-critical parts of the application code. A JVM is said to be “hot” when there is nothing left to optimize.</p>

<p>The warm-up procedure can be configured and guided by JVM command-line options. However, there are risks involved, because a misconfiguration may actually hamper the performance.</p>

<p>A JVM can be “warmed up” safely and easily by using the Java application in the intended way.
In the context of JPMML-Evaluator, this means evaluating data records until the average scoring time stabilizes.</p>

<p>The number of warm-up evaluations depends on the model type and complexity, but should be in the order of tens of thousands. Warm-up data records may be generated randomly based on the model schema, or be emebbed into the PMML document as the model verification dataset. 
The dataset does not need to consist of unique data records only. It is equally fine to iterate over a small but representative dataset multiple times.</p>

<h3 id="materials-and-methods">Materials and methods</h3>

<h5 id="dataset">Dataset</h5>

<p>The “audit” dataset is loaded from a CSV document into a <code class="language-plaintext highlighter-rouge">pandas.DataFrame</code>.
Automatic data type detection and conversion results in two continuous integer features, one continuous float feature, and five categorical string features.
The cardinality of string features is low, ranging from 2 to 16 category levels.</p>

<p>The data is pre-processed minimally, just to make it comply with Scikit-Learn base expectations.
Continuous features are standardized in the linear model case, and left as-is in the decision tree ensemble case. Categorical features are one-hot encoded.</p>

<h5 id="modeling">Modeling</h5>

<p>This exercise uses two binary classification algorithms with vastly different properties.</p>

<p>First, the linear model case as implemented by <a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html"><code class="language-plaintext highlighter-rouge">LogisticRegression</code></a> model.</p>

<p>The <code class="language-plaintext highlighter-rouge">LogisticRegression.predict(X)</code> method can almost completely be expressed using vectorized math operations:</p>

<ol>
  <li>Compute the decision function (row vector).</li>
  <li>Compute the probability distribution (row vector) by applying the sigmoid function to the decision function.</li>
  <li>Select the class label that corresponds to the peak of the probability distribution.</li>
</ol>

<p>As of Scikit-Learn version 0.24, the <code class="language-plaintext highlighter-rouge">predict(X)</code> method takes a shortcut and omits the second step (computation of the probability distribution) based on the premise that class label depends on the ranking, and not the magnitude, of decision function values. In other words, the application of sigmoid function is not necessary and should be avoided on a high cost-low merit basis (involves exponentiation).</p>

<p>Second, the decision tree ensemble case as implemented by <a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html"><code class="language-plaintext highlighter-rouge">RandomForestClassifier</code></a> model.</p>

<p>The <code class="language-plaintext highlighter-rouge">RandomForestClassifier.predict(X)</code> method computes the probability distribution by averaging the probability distributions of its member decision trees, and then selects the class label that corresponds to its peak.</p>

<p>The evaluation of decision trees relies on conditional logic. For better performance, decision trees are molded as balanced binary trees, and implemented in Cython.</p>

<p>The only operation that could benefit from vectorization is the averaging of probability distributions.
However, when looking into the source code of <code class="language-plaintext highlighter-rouge">predict(X)</code> and <code class="language-plaintext highlighter-rouge">predict_proba(X)</code> methods, then it can be seen that computation is carried out differently. This suggests that the performance gain from vectorization would be insufficient to compensate for the performance loss from allocating a temporary <code class="language-plaintext highlighter-rouge">(n_trees, n_classes)</code> data matrix.</p>

<p>Fitted pipelines are first dumped in pickle data format using the <code class="language-plaintext highlighter-rouge">joblib</code> package, and then converted to the PMML representation using the <a href="https://github.com/jpmml/sklearn2pmml"><code class="language-plaintext highlighter-rouge">sklearn2pmml</code></a> package.</p>

<h5 id="making-comparisons">Making comparisons</h5>

<p>The objective is measuring the pure prediction time.</p>

<p>The model and the input data matrix are loaded outside of the main time measurement loop.</p>

<p>In Python, the data is loaded into a <code class="language-plaintext highlighter-rouge">DataFrame</code> object using the <code class="language-plaintext highlighter-rouge">pandas.read_csv(path)</code> utility function, which automatically takes care of column data type detection and conversion.
In Java, the data is loaded manually into a list of maps <code class="language-plaintext highlighter-rouge">java.util.List&lt;java.util.Map&lt;String, ?&gt;&gt;</code>; map keys are strings, map values are Java primitive values (pre-parsed from the raw string value).</p>

<p>For batch testing purposes it is necessary to draw new custom size datasets off the base dataset.
This is done using random sampling with replacement.
It is inevitable that Python and Java samples come to contain different data records in different order. However, from the benchmarking perspective, this difference should not be significant, because all data records are considered to be functionally and computationally equivalent.</p>

<h3 id="results">Results</h3>

<h5 id="scikit-learn-1">Scikit-Learn</h5>

<p>The Scikit-Learn experiment is about quantifying the effect of batch size.</p>

<p>Scoring times are reported for three setups to make the “contribution” of the transformers stage and the model stage explicit:</p>

<ol>
  <li>Full pipeline - <code class="language-plaintext highlighter-rouge">y = pipeline.predict(X)</code></li>
  <li>All the data transformations steps of the pipeline (without the final estimator step) - <code class="language-plaintext highlighter-rouge">Xt = Pipeline(pipeline.steps[0:-1]).transform(X)</code></li>
  <li>Only the final estimator step - <code class="language-plaintext highlighter-rouge">y = Pipeline([pipeline.steps[-1]]).predict(Xt)</code>.</li>
</ol>

<p>By definition, the scoring time of setup #1 should equal the sum of scoring times of setups #2 and #3.</p>

<p>The setup can be controlled by supplying a third argument to the <code class="language-plaintext highlighter-rouge">benchmark.py</code> script (unset for setup #1; “transformers” and “model” for setups #2 and #3, respectively).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python benchmark.py &lt;path to PKL file&gt; &lt;path to CSV file&gt;
$ python benchmark.py &lt;path to PKL file&gt; &lt;path to CSV file&gt; "transformers"
$ python benchmark.py &lt;path to PKL file&gt; &lt;path to CSV file&gt; "model"
</code></pre></div></div>

<p>Logistic regression results:</p>

<table>
  <thead>
    <tr>
      <th>Configuration</th>
      <th>Tranformers time (μs)</th>
      <th>Model time (μs)</th>
      <th>Pipeline time (μs)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000 * 1</td>
      <td>6173.948</td>
      <td>94.990</td>
      <td>6268.938</td>
    </tr>
    <tr>
      <td>1000 * 10</td>
      <td>591.526</td>
      <td>9.775</td>
      <td>601.301</td>
    </tr>
    <tr>
      <td>1000 * 100</td>
      <td>60.858</td>
      <td>1.001</td>
      <td>61.859</td>
    </tr>
    <tr>
      <td>10 * 1000</td>
      <td>7.753</td>
      <td>0.136</td>
      <td>7.889</td>
    </tr>
    <tr>
      <td>10 * 10000</td>
      <td>2.216</td>
      <td>0.028</td>
      <td>2.244</td>
    </tr>
    <tr>
      <td>1 * 100000</td>
      <td>1.708</td>
      <td>0.024</td>
      <td>1.732</td>
    </tr>
  </tbody>
</table>

<p>Random forest results:</p>

<table>
  <thead>
    <tr>
      <th>Configuration</th>
      <th>Tranformers time (μs)</th>
      <th>Model time (μs)</th>
      <th>Pipeline time (μs)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000 * 1</td>
      <td>5764.249</td>
      <td>9583.312</td>
      <td>15347.561</td>
    </tr>
    <tr>
      <td>1000 * 10</td>
      <td>585.291</td>
      <td>1026.034</td>
      <td>1611.325</td>
    </tr>
    <tr>
      <td>1000 * 100</td>
      <td>59.495</td>
      <td>116.309</td>
      <td>175.804</td>
    </tr>
    <tr>
      <td>10 * 1000</td>
      <td>7.392</td>
      <td>18.779</td>
      <td>26.171</td>
    </tr>
    <tr>
      <td>10 * 10000</td>
      <td>2.175</td>
      <td>8.306</td>
      <td>10.481</td>
    </tr>
    <tr>
      <td>1 * 100000</td>
      <td>1.656</td>
      <td>7.387</td>
      <td>9.043</td>
    </tr>
  </tbody>
</table>

<p>The random error associated with time measurements is mitigated by running smaller-sized batches many times (and averaging their results).
Here, small batches are run 1000 times, medium batches 10 times, and large batches only once.
In the result tables (see above and below), run configurations are indicated using the formula <code class="language-plaintext highlighter-rouge">&lt;number of runs&gt; * &lt;batch size&gt;</code>. For example, the “1000 * 10” run configuration reads “create a batch of 10 data records, and invoke the <code class="language-plaintext highlighter-rouge">predict(X)</code> method 1000 times with it”.</p>

<p>The scoring times between <code class="language-plaintext highlighter-rouge">benchmark.py</code> script re-runs do not fluctuate more than 5%, which is considered excellent for a simplictic Python command-line application.</p>

<p>Transformer times between LR and RF are roughly the same.
The cost of the extra <code class="language-plaintext highlighter-rouge">StandardScaler</code> step for LR is barely noticeable, because it relies on vectorized math operations.</p>

<p>Model times for LR are around 100X to 300X shorter than for RF.
On a member decision tree model basis, the evaluation of linear models (0.024 microsec) is up to 4X faster than the evaluation of decision trees (7.387 / 71 = 0.104 microsec).</p>

<p>Looking at transformer times vs. model times reveals that the LR pipeline is fully limited by the data pre-processing step, whereas the RF pipeline is more balanced.</p>

<p>Pipeline times indicate that Scikit-Learn is very sensitive to batch sizing.
With smaller batch sizes (1 to 1’000 data records) the average scoring time decreases 10X as the size of batch increases 10X.
For example, it takes roughly the same amount of time to evaluate a batch of 1 and a batch of 100 (eg. the same data record cloned the specified number of times).</p>

<h5 id="jpmml-evaluator-in-java">JPMML-Evaluator in Java</h5>

<p>The JPMML-Evaluator experiment is about quantifying the effect of JVM warm-up status.</p>

<p>The workflow involves evaluating a variable-size warm-up batch, followed by a fixed-size (100’000 data records) main batch.
The hypothesis is that warmer JVM should deliver shorter scoring times.
Different parts of JPMML-Evaluator bytecode get compiled to native code at different times. The warm-up function is therefore expected to exhibit many minor cliffs, not just one major cliff (ie. a global transition from the “cold” state to the “hot” state).</p>

<p>The <code class="language-plaintext highlighter-rouge">benchmark.Demo</code> command-line application takes four arguments.
The first two are the locations of PMML and CSV files in the local filesystem, respectively.
The third argument is the language environment emulation mode (one of “Java” or “Python”), and the fourth one is the size of the warm-up batch.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -jar benchmark-executable-1.0-SNAPSHOT.jar &lt;path to PMML file&gt; &lt;path to CSV file&gt; "Java" &lt;warm-up batch size&gt;
</code></pre></div></div>

<p>Logistic regression results:</p>

<table>
  <thead>
    <tr>
      <th>Warm-up batch size</th>
      <th>Time (μs)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>9.500 – 12.720</td>
    </tr>
    <tr>
      <td>1</td>
      <td>9.250 – 10.460</td>
    </tr>
    <tr>
      <td>10</td>
      <td>8.930 – 10.730</td>
    </tr>
    <tr>
      <td>100</td>
      <td>9.690 – 10.610</td>
    </tr>
    <tr>
      <td>1000</td>
      <td>8.990 – 9.430</td>
    </tr>
    <tr>
      <td>10000</td>
      <td>5.820 – 7.040</td>
    </tr>
    <tr>
      <td>100000</td>
      <td>4.190 – 4.770</td>
    </tr>
  </tbody>
</table>

<p>Random forest results:</p>

<table>
  <thead>
    <tr>
      <th>Warm-up batch size</th>
      <th>Time (μs)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>98.230 – 107.760</td>
    </tr>
    <tr>
      <td>1</td>
      <td>93.400 – 101.260</td>
    </tr>
    <tr>
      <td>10</td>
      <td>97.410 – 100.170</td>
    </tr>
    <tr>
      <td>100</td>
      <td>90.650 – 95.110</td>
    </tr>
    <tr>
      <td>1000</td>
      <td>96.710 – 97.450</td>
    </tr>
    <tr>
      <td>10000</td>
      <td>91.570 – 95.760</td>
    </tr>
    <tr>
      <td>100000</td>
      <td>87.520 – 90.230</td>
    </tr>
  </tbody>
</table>

<p>The scoring times are tabulated in range notation, because they fluctuate considerably (up to 30%). The source of non-determinism is unclear.
The minimum and maximum values should adequately reflect the best and worst case performance, respectively. The expected value (ie. the mean of the distribution) remains unknown due to the small number of re-runs.</p>

<p>The JVM warm-up effect is well pronounced with LR, where scoring times differ ~2.5X between “cold” and “hot” states.
It can easily be overlooked with RF, where the this difference is roughly the same as the natural variance between scoring times (eg. the fastest “cold” scoring time is comparable to the slowest “hot” scoring time).</p>

<p>The warm-up functions appears to exhbit a similar shape in both cases.
There is a cliff between 0 and 1 batch sizes, then there is a slow and orderly descent between 1 and 10’000 batch sizes, followed by another cliff between 10’000 and 100’000 batch sizes.</p>

<p>The first cliff corresponds to JPMML-Evaluator internal lazy-loading/lazy-initialization work.
The descent corresponds to the JIT compilation of methods by the JVM. Methods are prioritized by their complexity and frequency of use. The JIT compilation starts with smaller and more popular methods, and proceeds until all JIT compilation-worthy methods have been processed.
The second cliff corresponds to reaching the “hot” state. The scoring time has reached a plateau, which will change only if the running JVM is perturbed with new information.</p>

<p>The JPMML-Evaluator library provides an <code class="language-plaintext highlighter-rouge">org.jpmml.evaluator.Evaluator#verify()</code> method, which evaluates the model with the embedded model verification dataset.
The above results show that model verification is good for crossing the first cliff, but is typically not adequate for reaching and crossing the second cliff.</p>

<p>Direct comparison of scoring times shows that JPMML-Evaluator outperforms Scikit-Learn with smaller batch sizes (below 1’000), but underperforms with larger batch sizes (over 10’000).
The best case is applying LR to a batch of 1, where JPMML-Evaluator outperforms by ~1000X (6268.938 / 4.770 = 1314).
The worst case is applying RF to a batch of 100’000, where JPMML-Evaluator underperforms by ~10X (9.043 / 90.230 = 0.1002).</p>

<p>It follows that Scikit-Learn and JPMML-Evaluator are complementary rather than competitive.</p>

<h5 id="jpmml-evaluator-in-python-component-analysis">JPMML-Evaluator in Python: component analysis</h5>

<p>The <a href="https://github.com/jpmml/jpmml-evaluator-python"><code class="language-plaintext highlighter-rouge">jpmml_evaluator</code></a> package provides a Python wrapper for the JPMML-Evaluator library.</p>

<p>The Java core is responsible for all heavy-lifting such as model loading and making predictions.
The Python driver to the Java core is responsible for the workflow coordination, data conversions and transfer.</p>

<p>Jumping back-and-forth between language environments is expensive.
In fact, the cost of calling Java from Python appears to be order(s) of magnitude higher than calling C from Python, which gives justification to devising rather complex schemes.</p>

<p>At the time of writing this (July 2021), the <code class="language-plaintext highlighter-rouge">jpmml_evaluator</code> package performs an evaluation round-trip as follows:</p>

<ol>
  <li>User/Python: unpack <code class="language-plaintext highlighter-rouge">DataFrame</code> to a list of dicts using the <code class="language-plaintext highlighter-rouge">DataFrame.to_dict(orient = "records")</code> method.</li>
  <li>User/Python: dump arguments (list of dicts) in pickle data format.</li>
  <li>System: (pass execution from Python to Java)</li>
  <li>User/Java: load arguments (<code class="language-plaintext highlighter-rouge">List&lt;Map&lt;String, ?&gt;&gt;</code> from the pickle arguments dump.</li>
  <li>User/Java: iterate over arguments, evaluate, collect results.</li>
  <li>User/Java: dump results (<code class="language-plaintext highlighter-rouge">List&lt;Map&lt;String, ?&gt;&gt;</code>) in pickle data format.</li>
  <li>System: (pass execution from Java back to Python)</li>
  <li>User/Python: load results (list of dicts) from the pickle results dump.</li>
  <li>User/Python: pack list of dicts to <code class="language-plaintext highlighter-rouge">DataFrame</code> using the <code class="language-plaintext highlighter-rouge">DataFrame.from_records(iterable of dicts)</code> function.</li>
</ol>

<p>The JPMML-Evaluator-Python experiment is about quantifying the total cost of the Python data handler (steps #1, #2, #8 and #9), and its Java counterpart (steps #4 and #6).
The cost of running JPMML-Evaluator in Java (step #5) is already known separately.</p>

<p>All this data handler complexity exists for the sole purpose of mapping complex Python data structures to Java, and back.</p>

<p>The Python data science stack has the advantage that all Python tools and libraries can interface/communicate with each other directly using small number of standardized data structures.
If the data resides in shared memory, then Python application components can simply pass a memory reference to the data between each other.</p>

<p>Unfortunately, Java tools and libraries cannot interface with Pandas’ data frames or Numpy arrays in a similar way.
The workaround is to deconstruct complex/language-specific data structures into simpler/language-agnostic data structures, which are adequately supported by both sides.</p>

<p>The <code class="language-plaintext highlighter-rouge">jpmml_evaluator</code> package communicates between Python and Java environments using the pickle protocol.
Since <code class="language-plaintext highlighter-rouge">DataFrame</code> is a complex data structure that does not have a Java equivalent, it is deconstructed into a list of dicts (data record-oriented API), which maps to a <code class="language-plaintext highlighter-rouge">List&lt;Map&lt;?, ?&gt;&gt;</code>.
Pickling uses native encoders on the Python side, and the <a href="https://github.com/irmen/pickle">Pickle</a> library on the Java side.</p>

<h6 id="java-data-handler">Java data handler</h6>

<p>The <code class="language-plaintext highlighter-rouge">benchmark.Main</code> application has “Python” language environment emulation mode, which adds arguments unpickling and results pickling work to the core “Java” mode.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -jar benchmark-executable-1.0-SNAPSHOT.jar &lt;path to PMML file&gt; &lt;path to CSV file&gt; "Python" 100000
</code></pre></div></div>

<p>Logistic regression results:</p>

<table>
  <thead>
    <tr>
      <th>Configuration</th>
      <th>Time (μs)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000 * 1</td>
      <td>68.000 – 104.000</td>
    </tr>
    <tr>
      <td>1000 * 10</td>
      <td>27.200 – 43.800</td>
    </tr>
    <tr>
      <td>1000 * 100</td>
      <td>7.500 – 7.900</td>
    </tr>
    <tr>
      <td>10 * 1000</td>
      <td>8.300 – 11.000</td>
    </tr>
    <tr>
      <td>10 * 10000</td>
      <td>6.180 – 6.450</td>
    </tr>
    <tr>
      <td>1 * 100000</td>
      <td>5.740 – 5.980</td>
    </tr>
  </tbody>
</table>

<p>Random forest results:</p>

<table>
  <thead>
    <tr>
      <th>Configuration</th>
      <th>Time (μs)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000 * 1</td>
      <td>115.000 – 150.000</td>
    </tr>
    <tr>
      <td>1000 * 10</td>
      <td>90.900 – 96.900</td>
    </tr>
    <tr>
      <td>1000 * 100</td>
      <td>92.240 – 97.190</td>
    </tr>
    <tr>
      <td>10 * 1000</td>
      <td>90.300 – 94.900</td>
    </tr>
    <tr>
      <td>10 * 10000</td>
      <td>88.910 – 93.280</td>
    </tr>
    <tr>
      <td>1 * 100000</td>
      <td>88.900 – 94.030</td>
    </tr>
  </tbody>
</table>

<p>The pickling overhead for each batch size can be estimated by subtracting the JPMML-Evaluator scoring time from the tabulated scoring times.
The cost function appears to exhibit a 30 – 60 microsecs fixed part, and a 1 – 1.5 microsecs variable part.</p>

<h6 id="python-data-handler">Python data handler</h6>

<p>The <code class="language-plaintext highlighter-rouge">benchmark.py</code> script has “Dummy” mode, where the predictions are made by a dummy (no-op) model.
To eliminate any systematic bias or error, this model returns a three-column data matrix (string class label, double probabilities of event and no-event) as is typical with binary classifiers.</p>

<p>Pickling is done using the pickle 2 protocol version.
Compression is turned off, because it would consume CPU cycles (cf. memory or IO bandwidth), which is the scarcest resource during benchmarking.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python benchmark.py &lt;path to PKL file&gt; &lt;path to CSV file&gt; "Dummy"
</code></pre></div></div>

<p>Dummy model results:</p>

<table>
  <thead>
    <tr>
      <th>Configuration</th>
      <th>Time (μs)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000 * 1</td>
      <td>217.917</td>
    </tr>
    <tr>
      <td>1000 * 10</td>
      <td>17.906</td>
    </tr>
    <tr>
      <td>1000 * 100</td>
      <td>2.360</td>
    </tr>
    <tr>
      <td>10 * 1000</td>
      <td>3.179</td>
    </tr>
    <tr>
      <td>10 * 10000</td>
      <td>0.684</td>
    </tr>
    <tr>
      <td>1 * 100000</td>
      <td>0.752</td>
    </tr>
  </tbody>
</table>

<p>The cost function appears to exhibit a ~200 microsecs fixed part, and a 0.5 – 1 microsecs variable part.</p>

<h5 id="jpmml-evaluator-in-python-complete-workflow-analysis">JPMML-Evaluator in Python: complete workflow analysis</h5>

<p>The summation of component times gives the “user” workflow time, but there is an additional “system” workflow time, which corresponds to Python calling Java via some inter-process communication technology (steps #3 and #7).</p>

<p>The <code class="language-plaintext highlighter-rouge">benchmark.py</code> script has “JPMML/PyJNIus” and “JPMML/Py4J” modes for activating the <a href="https://github.com/kivy/pyjnius">PyJNIus</a> and <a href="https://www.py4j.org/">Py4J</a> backends, respectively.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python benchmark.py &lt;path to PMML file&gt; &lt;path to CSV file&gt; "JPMML/PyJNIus"
$ python benchmark.py &lt;path to PMML file&gt; &lt;path to CSV file&gt; "JPMML/Py4J"
</code></pre></div></div>

<p>Logistic regression results:</p>

<table>
  <thead>
    <tr>
      <th>Configuration</th>
      <th>PyJNIus time (μs)</th>
      <th>Py4J time (μs)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000 * 1</td>
      <td>1453.429 – 1602.972</td>
      <td>1835.353 – 2227.383</td>
    </tr>
    <tr>
      <td>1000 * 10</td>
      <td>167.379 – 182.924</td>
      <td>221.774 – 249.934</td>
    </tr>
    <tr>
      <td>1000 * 100</td>
      <td>37.410 – 39.164</td>
      <td>46.621 – 47.625</td>
    </tr>
    <tr>
      <td>10 * 1000</td>
      <td>25.152 – 30.576</td>
      <td>91.389 – 104.549</td>
    </tr>
    <tr>
      <td>10 * 10000</td>
      <td>21.770 – 23.646</td>
      <td>38.932 – 39.747</td>
    </tr>
    <tr>
      <td>1 * 100000</td>
      <td>22.058 – 22.587</td>
      <td>23.504 – 23.762</td>
    </tr>
  </tbody>
</table>

<p>Random forest results:</p>

<table>
  <thead>
    <tr>
      <th>Configuration</th>
      <th>PyJNIus time (μs)</th>
      <th>Py4J time (μs)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000 * 1</td>
      <td>1683.092 – 1866.688</td>
      <td>2077.538 – 2423.054</td>
    </tr>
    <tr>
      <td>1000 * 10</td>
      <td>283.360 – 304.195</td>
      <td>343.828 – 357.657</td>
    </tr>
    <tr>
      <td>1000 * 100</td>
      <td>122.838 – 130.278</td>
      <td>139.218 – 145.169</td>
    </tr>
    <tr>
      <td>10 * 1000</td>
      <td>104.193 – 107.398</td>
      <td>218.086 – 231.611</td>
    </tr>
    <tr>
      <td>10 * 10000</td>
      <td>100.216 – 101.682</td>
      <td>121.297 – 124.476</td>
    </tr>
    <tr>
      <td>1 * 100000</td>
      <td>100.881 – 102.534</td>
      <td>106.926 – 110.737</td>
    </tr>
  </tbody>
</table>

<p>The Python-to-Java backend overhead can be estimated for each batch size by subtracting the sum of data handler times from the tabulated scoring times.
It appears to be a fixed cost somewhere in the 1100 – 1300 microsecs (PyJNIus) or 1500 – 1700 microsecs (Py4J) range.</p>

<p>The PyJNIus backend has lower overhead than the Py4J backend.
However, the difference between the two is not that big in relative terms, which gives application developers freedom to work with either one.</p>

<h3 id="main-observations-and-conclusions">Main observations and conclusions</h3>

<h5 id="general">General</h5>

<ul>
  <li>
    <p>Benchmarking should be carried out using a setup that mimics the intended production setup as closely as possible. Benchmarking unrelated transformer and model types with unrelated datasets is a fool’s errand.</p>
  </li>
  <li>
    <p>Benchmarking is about determining the shape of all relevant cost functions. Once known, they can be analyzed individually (location and interpretation of cliffs), or overlayed with each other (location and interpretation of crossing points).</p>
  </li>
  <li>
    <p>Separating fixed costs (per batch) from variable costs (per each data record in the batch).
The ratio between fixed costs vs. variable costs dictates the minimum efficient batch size. Fixed costs typically dominate over variable costs, so the scoring time per data record decreases as the batch size increases. The optimal batch size is where the scoring times have reached a plateau. Pushing for even larger batch sizes may cause the scoring time per data record to begin increasing again due to new kinds of system-level fixed costs.</p>
  </li>
  <li>
    <p>Benchmarking using command-line applications assumes repeatability (ie. the consistency of results between identically configured runs). Python meets this requirement well (less than 5% variance), but Java not so much (10 – 30% variance). The workaroud is to report results as ranges (observed minimum and maximum values over a number of runs).</p>
  </li>
  <li>
    <p>Benchmarking Java libraries and tools is sensitive towards the JVM warm-up status. The scoring times between “cold” and “hot” states may differ substantially. The warm-up needs to be complete relative to this part of the codebase that is being measured; unrelated parts may be left cold or lukewarm.</p>
  </li>
</ul>

<h5 id="scikit-learn-2">Scikit-Learn</h5>

<ul>
  <li>
    <p>Scikit-Learn is designed around the batch processing idea, because it addresses both model training and model deployment concerns.</p>
  </li>
  <li>
    <p>Scikit-Learn is characterized by high fixed costs (5000 microsec per batch) and medium-to-low variable costs (2 to 10 microsec per data record).
Fixed costs are associated with managing Numpy arrays throughout the workflow. Variable costs are significant if the workflow deals with complex data type features (eg. strings, temporals, user-defined data types) that require transformation to numeric representation.
Variable costs are almost negligible when working with all-numeric data.</p>
  </li>
  <li>
    <p>Scikit-Learn benchmarks should measure transformers time and model time separately. Data pre-processing is often the rate-limiting step. The bottleneck can sometimes be relieved by simply reordering or restructuring transformer steps.</p>
  </li>
  <li>
    <p>Scikit-Learn can and will take advantage of vectorized math operations. However, the implementation resides at the C language layer, which limits its utility with smaller batch sizes.</p>
  </li>
</ul>

<h5 id="jpmml-evaluator-in-java-1">JPMML-Evaluator in Java</h5>

<ul>
  <li>
    <p>JPMML-Evaluator and its derivatives are designed exclusively around the model deployment concern.
In the PMML approach, the model training part is left to specialized ML frameworks such as Apache Spark, R or Scikit-Learn. The fitted pipelines are converted to the PMML representation using high-quality JPMML family conversion tools and libraries.
The foundation for success is already laid in the conversion stage, because JPMML converters perform sophisticated analyses and optimizations, which result in smallest, cleanest and most robust PMML documents.</p>
  </li>
  <li>
    <p>JPMML-Evaluator is characterized by zero fixed costs and medium variable costs (5 to 100 microsec per data record).
Variable costs depend more on the model type, and less on the model schema.</p>
  </li>
  <li>
    <p>JPMML-Evaluator computes the prediction by lazily evaluating one big computation graph.
The scoring path, and hence the scoring time, depends on the feature values of a data record. For some data records they are shorter, for others longer. The expected scoring time can be estimated by averaging the scoring times of all data records in a dataset.</p>
  </li>
  <li>
    <p>JPMML-Evaluator is oriented towards real-time and near real-time prediction (eg. stream scoring), where the data comes in sporadically, and has to be acted on immediately. However, it is also applicable to batch prediction, even though its peak throughput is limited due to the unavailability of vectorized math operations.</p>
  </li>
</ul>

<h5 id="jpmml-evaluator-in-python">JPMML-Evaluator in Python</h5>

<ul>
  <li>
    <p>JPMML-Evaluator-Python is characterized by high fixed costs (1000 to 1500 microsec per batch) and medium variable costs (20 to 100 microsec per data record).
The fixed costs stem from Python-to-Java inter-process communication, and are difficult to get around using the existing PyJNIus or Py4J backends.</p>
  </li>
  <li>
    <p>JPMML-Evaluator-Python is one or two orders of magnitude slower than JPMML-Evaluator, which limits its utility for real-time prediction. However, it is still competitive with Scikit-Learn when dealing with small batches.</p>
  </li>
</ul>

<h3 id="resources">Resources</h3>

<ul>
  <li>“Audit” dataset: <a href="https://openscoring.io/resources/data/audit.csv"><code class="language-plaintext highlighter-rouge">audit.csv</code></a></li>
  <li>Python scripts: <a href="https://openscoring.io/resources/2021-08-04/train.py"><code class="language-plaintext highlighter-rouge">train.py</code></a> and <a href="https://openscoring.io/resources/2021-08-04/benchmark.py"><code class="language-plaintext highlighter-rouge">benchmark.py</code></a></li>
  <li>Java application: <a href="https://openscoring.io/resources/2021-08-04/benchmark.zip"><code class="language-plaintext highlighter-rouge">benchmark.zip</code></a></li>
</ul>

</div>



  </main>

  <footer class="footer">
  <div class="container">
    <div class="mb-6">© 2022 - Openscoring</div>

    <div class="mb-6">
      <ul class="flex gap-4 list-none">
        <li>
          <a href="mailto:info@openscoring.io" aria-label="email">
            <img src="/assets/images/email_round.svg" width="48" height="48" alt="Contact Openscoring">
          </a>
        </li>
        <li>
          <a href="https://twitter.com/openscoring" target="_blank" aria-label="twitter">
            <img src="/assets/images/twitter_round.svg" width="48" height="48" alt="Follow Openscoring on Twitter">
          </a>
        </li>
      </ul>
    </div>
  </div>
</footer>

  <script>
  var sc_project=11704106;
  var sc_security="a7d1bf16"; 
  var sc_invisible=1; 
  var sc_remove_link=1; 
</script>

<script src="https://www.statcounter.com/counter/counter.js" async></script>

<noscript>
  <div class="statcounter">
    <img class="statcounter" src="https://c.statcounter.com/11704106/0/a7d1bf16/1/" alt="Web Analytics Made Easy - Statcounter" referrerPolicy="no-referrer-when-downgrade">
  </div>
</noscript>
</body>

</html>
